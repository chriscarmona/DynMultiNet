#' @title
#'    Bayesian Learning of Dynamic Multilayer Networks with binary data
#'
#' @description
#'    \code{dmn_sampling} Implements model from Durante and Dunson, 2018
#'
#' @param net_data Data frame.Network information.
#' @param pred_data Data frame. Linked predictors information.
#' @param directed Boolean. Indicates if the provided network is directed, i.e. the adjacency matrix is assymetrical.
#' @param weighted Boolean. Indicates if the provided network is weighted, i.e. edges with values other that 0 and 1.
#' @param H_dim Integer. Latent space dimension.
#' @param R_dim Integer. Latent space dimension, for layer specific latent vectors.
#' 
#' @param delta_mu Positive scalar. Hyperparameter for the smoothness of movements of the baseline process for link probabilities. In general, you won't be able to extrapolate more than \code{delta_mu} units away from your data.
#' @param delta_x Positive scalar. Hyperparameter for the smoothness of movements of the latent coordinates that correspond to link probabilities.
#' @param delta_p Positive numeric vector. Hyperparameter for the smoothness of movements of predictor coefficients.
#' 
#' @param delta_lambda Positive scalar. Hyperparameter for the smoothness of movements of the baseline process for link weight. In general, you won't be able to extrapolate more than \code{delta_lambda} units away from your data.
#' @param delta_u Positive scalar. Hyperparameter for the smoothness of movements of the latent coordinates that correspond to link weights.
#' @param delta_p Positive numeric vector. Hyperparameter for the smoothness of movements of predictor coefficients that correspond to link weights.
#' 
#' @param a_1 Positive scalar. Hyperparameter for number of effective dimensions in the latent space.
#' @param a_2 Positive scalar. Hyperparameter for number of effective dimensions in the latent space.
#' @param inference_type Character. Inferential procedure for the estimation of posterior distributions. One of "mcmc" (default) or 'vb".
#' @param n_chains_mcmc Integer. Number of chains for the MCMC.
#' @param n_iter_mcmc Integer. Number of iterations for the MCMC.
#' @param n_burn Integer. Number of iterations discarded as part of the MCMC warming up period at the beginning of the chain.
#' @param n_thin Integer. Number of iterations discarded for thining the chain (reducing the autocorrelation). We keep 1 of every n_thin iterations.
#' @param time_fc Numeric vector. Specifies times in the networks to be forecasted.
#' @param out_file String. Indicates a file (.RData) where the output will be saved.
#' @param log_file String. Indicates a file (.txt) where the log of the process will be saved.
#' @param quiet_mcmc Boolean. Indicates if silent mode is preferes, if \code{FALSE} progress update is displayed.
#' @param parallel_mcmc Boolean. Indicates if some steps in the mcmc would be processed in parallel.
#' @param only_read_csv_stan_fit Boolean. Indicates if the sampling process is skipped and only reads the csv output from a previous run.
#' 
#' @details
#'    The model assumes a latent variable approach
#'    
#'    \code{net_data} must be a data frame with the following columns
#'        \describe{
#'        \item{\code{source}}{Start Node}
#'        \item{\code{target}}{End node}
#'        \item{\code{weight}}{Edge weight}
#'        \item{\code{time}}{time associated with the edge}
#'        \item{\code{layer}}{Layer associated with the edge}
#'        }
#'
#' @return
#'    A list with the following components:
#' \describe{
#'     \item{\code{theta_mcmc}}{Matrix with the chain of the parameters in the model.}
#' }
#'
#'
#' @examples
#' 
#' \dontrun{
#' 
#' set.seed(0)
#' 
#' synth_net <- gen_synth_net( node_all = seq(1,10),
#'                             time_all = seq(1,15),
#'                             layer_all = seq(1,3),
#'                             directed = FALSE,
#'                             H_dim = 3, R_dim = 3,
#'                             a_1 = 1.5, a_2 = 2.5 )
#' 
#' set.seed(0)
#' net_mcmc <- dmn_sampling( net_data = synth_net$edge_data,
#'                           pred_data = NULL,
#'                           directed = FALSE,
#'                           H_dim = 10, R_dim = 5,
#'                           a_1 = 2, a_2 = 2,
#'                           n_iter_mcmc = 2000 )
#' }
#' 
#' @useDynLib DynMultiNet
#' 
#' @import dplyr
#' 
#' @export
#' 

dmn_sampling <- function( net_data,
                          pred_data=NULL,
                          directed=FALSE, weighted=FALSE,
                          H_dim=10, R_dim=10,
                          
                          delta_mu=5,
                          delta_x=5,
                          delta_p=5,
                          
                          delta_lambda=5,
                          delta_u=5,
                          delta_q=5,
                          
                          a_1=2, a_2=2.5,
                          
                          inference_type=c("mcmc","vb")[1],
                          
                          n_chains_mcmc=1,
                          n_iter_mcmc=1000, n_burn=n_iter_mcmc/2, n_thin=3,
                          time_fc=NULL,
                          out_file=NULL, log_file=NULL,
                          quiet_mcmc=FALSE,
                          parallel_mcmc=FALSE,
                          only_read_csv_stan_fit=FALSE ) {
  
  mcmc_clock <- Sys.time()
  
  if(!is.null(pred_data)) {
    if( !all( is.element(unique(pred_data[,"layer"]),c(NA,unique(net_data$layer))) ) ) {
      stop('Layers in "pred_data" must be one of layers in "net_data"')
    }
  }
  
  #### Start: Processing data ####
  ### Network data ###
  y_ijtk <- get_y_ijtk_from_edges( net_data,
                                   directed=directed,
                                   weighted=weighted,
                                   self_edges=FALSE )
  node_all <- sort(unique(unlist(net_data[,c("source","target")])))
  V_net <- length(node_all)
  time_net <- sort(unique(unlist(net_data$time)))
  T_net <- length(time_net)
  layer_all <- sort(unique(unlist(net_data$layer)))
  K_net <- length(layer_all)
  
  if(any(is.element(time_fc,time_net))) {
    warning('Some elements in "time_fc" are already in the network observed data.')
    time_fc <- time_fc[!is.element(time_fc,time_net)]
  }
  
  time_all <- sort(c(time_net,time_fc))
  time_all_idx_net <- which(is.element(time_all,time_net))
  
  ### Predictors data ###
  # Pending: do something for predictors and time_fc
  pred_net <- get_z_pred( pred_data,
                          node_all, time_all, layer_all,
                          quiet=FALSE )
  
  pred_all <- pred_net$pred_all
  
  pred_id_layer <- pred_net$pred_id_layer
  pred_id_edge <- pred_net$pred_id_edge
  
  z_tkp<-pred_net$z_tkp
  z_ijtkp<-pred_net$z_ijtkp
  
  #### End: Processing data ####
  
  
  if( !is.null(log_file) ) {
    model_des <- "Dynamic"
    if(K_net==1) {
      model_des <- paste(model_des," single-layer network,",collapse="")
    } else if(K_net>1) {
      model_des <- paste(model_des," multi-layer network,",collapse="")
    }
    if(directed) {
      model_des <- paste(model_des," directed",collapse="")
    } else {
      model_des <- paste(model_des," undirected",collapse="")
    }
    if(weighted) {
      model_des <- paste(model_des," weighted edges",collapse="")
    } else {
      model_des <- paste(model_des," unweighted edges",collapse="")
    }
    
    cat("**** DynMultiNet *****\n",
        
        "\n----- Network topology -----\n",
        "Nodes = ",V_net,"\n",
        "Layers = ",K_net,"\n",
        "Times steps = ",T_net,"\n",
        "Directed = ",directed,"\n",
        "Weighted = ",weighted,"\n",
        
        "\n----- Inferential parameters -----\n",
        "H_dim = ",H_dim,"\n",
        "R_dim = ",R_dim,"\n",
        
        "delta_mu =",delta_mu,"\n",
        "delta_x =",delta_x,"\n",
        "delta_p =",delta_p,"\n",
        
        "delta_lambda =",delta_lambda,"\n",
        "delta_u =",delta_u,"\n",
        "delta_q =",delta_q,"\n",
        
        "a_1 = ",a_1,"\n",
        "a_2 = ",a_2,"\n",
        
        "\n----- MCMC parameters -----\n",
        "n_chains_mcmc = ",n_chains_mcmc,"\n",
        "n_iter_mcmc = ",n_iter_mcmc,"\n",
        "n_burn = ",n_burn,"\n",
        "n_thin = ",n_thin,"\n",
        
        "\n----- Network forecasting -----\n",
        "time_fc = ", paste(time_fc,collapse=","), "\n",
        
        "\n----- Storage and processing -----\n",
        "out_file = ",paste(out_file,".rds",sep=""),"\n",
        "log_file = ",paste(log_file,".txt",sep=""),"\n",
        "parallel_mcmc = ",parallel_mcmc,"\n",
        "\n---------------------------\n",
        "\nProcess starting time:\n",as.character(mcmc_clock),"\n",
        "\n---------------------------\n",
        "\nMCMC Starting time:\n",as.character(Sys.time()),"\n",
        "\n---------------------------\n\n",
        file=paste(log_file,".txt",sep="") )
  }
  mcmc_clock <- Sys.time()
  
  if(inference_type=="mcmc") {
    dmn_mcmc <- mcmc_stan( y_ijtk=y_ijtk,
                           node_all=node_all, time_all=time_all, layer_all=layer_all,
                           time_all_idx_net=time_all_idx_net,
                           
                           pred_all=pred_all,
                           pred_id_layer=pred_id_layer, pred_id_edge=pred_id_edge,
                           z_tkp=z_tkp, z_ijtkp=z_ijtkp,
                           
                           H_dim=H_dim, R_dim=R_dim,
                           
                           delta_mu=delta_mu,
                           delta_x=delta_x,
                           delta_p=delta_p,
                           
                           delta_lambda=delta_lambda,
                           delta_u=delta_u,
                           delta_q=delta_q,
                           
                           a_1=a_1, a_2=a_2,
                           
                           directed=directed,
                           weighted=weighted,
                           
                           n_chains_mcmc=n_chains_mcmc,
                           n_iter_mcmc=n_iter_mcmc, n_burn=n_burn, n_thin=n_thin,
                           
                           out_file=out_file,
                           quiet_mcmc=quiet_mcmc,
                           only_read_csv_stan_fit=only_read_csv_stan_fit )
  } else if (inference_type=="vb") {
    dmn_mcmc <- mcmc_stan_vb( y_ijtk=y_ijtk,
                              node_all=node_all, time_all=time_all, layer_all=layer_all,
                              time_all_idx_net=time_all_idx_net,
                              
                              pred_all=pred_all,
                              pred_id_layer=pred_id_layer, pred_id_edge=pred_id_edge,
                              z_tkp=z_tkp, z_ijtkp=z_ijtkp,
                              
                              H_dim=H_dim, R_dim=R_dim,
                              
                              delta_mu=delta_mu,
                              delta_x=delta_x,
                              delta_p=delta_p,
                              
                              delta_lambda=delta_lambda,
                              delta_u=delta_u,
                              delta_q=delta_q,
                              
                              a_1=a_1, a_2=a_2,
                              
                              directed=directed,
                              weighted=weighted,
                              
                              n_chains_mcmc=n_chains_mcmc,
                              n_iter_mcmc=n_iter_mcmc, n_burn=n_burn, n_thin=n_thin,
                              
                              out_file=out_file,
                              quiet_mcmc=quiet_mcmc,
                              only_read_csv_stan_fit=only_read_csv_stan_fit )
  }
  
  if( !is.null(log_file) ) {
    cat("MCMC Finish time:\n",as.character(Sys.time()),"\n\n",
        "---------------------------\n\n\n",
        file=paste(log_file,".txt",sep=""),append=T )
  }
  
  return( dmn_mcmc )
  
}
